<?php
// Integrates with Penn State Webaccess
// Maintained by the Drupal @ PSU community
// based originally on webserver_auth.module

/**
 * Implements hook_init().
 */
function webaccess_init() {
  global $user;
  global $base_url;
  // stop if we have an account actively logged in or this is a drush agent
  if (($user->uid && _webaccess_verify_current_user($user)) || drupal_is_cli()) {
  }
  else {
    // test for a case where the user is currently logged in but really shouldn't be
    // this is also able to detect users logged in with incorrect account
    if ($user->uid && !(_webaccess_verify_current_user($user)) && module_exists('webaccess_forms')) {
      // Destroy the current session:
      session_destroy();
      // edge case where this isn't set, avoid notice
      if (isset($_SERVER['COSIGN_SERVICE'])) {
        $service_name = $_SERVER['COSIGN_SERVICE'];
        setcookie( $service_name , "null", time()-1, '/', "", 1 );
      }
      // needs to ask webaccess to be invoked again at current location
      $uri = request_uri();
      $base = base_path();
      $pos = strpos($uri, $base);
      if ($pos !== false) {
        $uri = substr_replace($uri, '/', $pos, strlen($base));
      }
      $uri = $base_url . $uri;
      // then make the call to webaccess, allowing for redirection to the path requested
      _webaccess_call($uri);
    }
    $authname = '';
    // set the authorization name to the remote user variable
    if (isset($_SERVER['REMOTE_USER'])) {
      $authname = $_SERVER['REMOTE_USER'];
    }
    // if we have one and webaccess is enabled, perform a login
    if ((!empty($authname)) && variable_get("webaccess_init_enable", "")) {
      // allow other webaccess hooks to fire
      module_invoke_all("webaccess");
      // ensure user module is loaded, edge cases this may not be
      if (!module_exists('user')) {
       drupal_load('module', 'user');
      }
      // perform the login
      _webaccess_do_logon();
    }
    // if this is marked as a secure site
    // and the php auth user is not set
    // and webaccess is told to initialize prior to the page loading
    // and the address requested is not the full remote cron operation
    else if (variable_get("webaccess_secure_site", "")
              && !isset($_SERVER['PHP_AUTH_USER'])
              && variable_get("webaccess_init_enable", "")
             ) {
      // test for cron to allow remote running as well as support
      // additional arguments being passed.  all we care about to
      // allow webaccess to be bypassed is that the base of the request
      // address matches what would commonly allow an access bypass in
      // drupal to run cron. This opens a hole directly to run cron.php
      // which is not within scope of logging a user in so its compatible
      // with drupal core as well as webaccess strict implementations
      $cron_base = $GLOBALS['base_path'] . 'cron.php?cron_key=' . variable_get('cron_key', '');
      // see if this starts with the cron base
      if (strpos(request_uri(), $cron_base) === 0) {
        return TRUE;
      }
      // test for lti, block forced redirect if it is a valid lti request
      // the LTI call is what's actually building the user account and
      // authorizing its existance, something that needs to traditionally
      // preceed webaccess account creation.  This allows for valid LTI
      // calls to pass through without getting kicked out, which creates
      // the effect of LTI producing a user account / role which webaccess
      // lets happen and then automatically respects.  This allows for
      // on the fly authorization and authentication, kind of a big deal.
      if (module_exists('lti_tool_provider') && arg(0) == 'lti') {
        if (lti_tool_provider_is_basic_lti_request()) {
          return TRUE;
        }
      }
      // allow async calls to happen as they are internal spidering out
      // as HTTPL is making internal calls against itself this isn't a huge
      // deal to have happen.  It's effectively allowing the server to make
      // annonymous calls against itself.  Only the box can produce these calls
      // as it has internal pub/priv key matching which that function assures
      // whether or not that's even allowed.  Directly accessing this address
      // without the box producing it will result in a forbidden error.
      if (module_exists('httprl') && arg(0) == 'httprl_async_function_callback') {
        return TRUE;
      }
      // this test is for css/js generated by advagg module to
      // allow those files to be generated via HTTPRL or directly
      // by calls inside the module.  This is a hyper efficient method
      // of producing css / js in aggregated form and without supporting
      // this module we leave sites behind the performance curve.
      // The below preg match is testing that it's a valid portion of the
      // advagg file structure that's trying to be touched which is a
      // file hash to generate the file.  This is impossible to reproduce
      // as a result.
      if (module_exists('advagg') &&
          strpos(request_uri(), 'files/advagg_') != 0 &&
          preg_match("/^" . preg_quote(file_create_url(file_build_uri('advagg_')), '/') . "/", (preg_replace('/\?.*/', '', str_replace(base_path(), '', $base_url . '/') . request_uri())))) {
        return TRUE;
      }
      // if we pass all the above loopholes, we know this is a request that
      // needs to ask webaccess to be invoked
      $uri = request_uri();
      $base = base_path();
      $pos = strpos($uri, $base);
      if ($pos !== false) {
        $uri = substr_replace($uri, '/', $pos, strlen($base));
      }
      $uri = $base_url . $uri;
      // then make the call to webaccess, allowing for redirection to the path requested
      _webaccess_call($uri);
      exit;
    }
  }
}

/**
 * Callback to perform logon
 */
function _webaccess_do_logon() {
  global $user;
  $authname = '';
  if (isset($_SERVER['REMOTE_USER'])) {
    $authname = $_SERVER['REMOTE_USER'];
  }
  // FPS and LDAP checks for authorization
  $realm_check = 1;
  // verify realm, typically this is dce.psu.edu for non FPS accounts
  $required_realm = variable_get("webaccess_require_realm", "");
  if ($required_realm != "") {
    if ($required_realm != $_SERVER['REMOTE_REALM']) {
      $realm_check = 0;
    }
  }
  if ($realm_check == 1) {
    // attempt to load an account based only on the username
    // this name is as it exists in the authname table
    // it can differ from $user->name but is not recommended
    if (!($account = user_external_load($authname))) {
      // load user on match of internal name
      if ($account = user_load_by_name($authname)) {
        // this binds the webaccess username to the drupal uid / user account
        user_set_authmaps($account, array("authname_webaccess" => $authname));
      }
      else {
        // verify that drupal settings allow accounts to be created automatically
        if (variable_get('user_register', 1) != 0) {
          // Register this new user.
          $userinfo = array(
            'name' => $authname,
            'pass' => user_password(),
            'init' => $authname,
            'status' => 1,
            'access' => REQUEST_TIME,
          );
          if ($domain = variable_get("webaccess_domain", "")) {
            // email defaults to domain variable defined in admin section (psu.edu typically)
            $userinfo['mail'] = $authname . "@$domain";
          }
          $account = user_save(drupal_anonymous_user(), $userinfo);
          // Terminate if an error occurred during user_save().
          if (!$account) {
            drupal_set_message(t("Error saving user account."), 'error');
            return;
          }
          user_set_authmaps($account, array("authname_webaccess" => $authname));
        }
      }
    }
    // log user in by faking a user login form submission
    $form_state['uid'] = $account->uid;
    user_login_submit(array(), $form_state);
  }
  else {
    // rare message, typically you get this if you have an FPS account and access is being blocked
    drupal_set_message(t('Access for @remuser denied. (Wrong Realm)', array('@remuser' => $_SERVER['REMOTE_USER'])));
  }
}

/**
 * Auth routines for redirects
 */
function _webaccess_call($uri = "") {
  global $user;
  global $base_url;
  if ($uri == "") {
    $uri = $_SERVER['HTTP_REFERER'];
  }
  if ($uri == "") {
    $uri = $GLOBALS['base_path'];
  }
  // this is the magic that pushes you over to webaccess if you currently aren't logged in
  if (!($user->uid)) {
    drupal_goto($base_url . '/login/cosign?redirect_url=' . $uri);
  }
  else {
    // return to home page if path existed
    if ($uri == "") {
       $uri = base_path();
    }
    drupal_goto($uri);
  }
}

/**
 * Callback to perform redirect.
 */
function _webaccess_redirect() {
  global $user;
  global $base_url;
  // verify that the redirect url is on the same site of origin
  $uri = '';
  if (isset($_GET['redirect_url'])) {
    $uri = check_url($_GET['redirect_url']);
    // account for quotes bring encoded
    $uri = str_replace('&quot;', '"', $uri);
    // ensure addresses don't have http/https incase of mixed mode auth
    $uri = str_replace('http://', '', $uri);
    $uri = str_replace('https://', '', $uri);
  }
  $check_uri = str_replace('http://', '', $base_url);
  $check_uri = str_replace('https://', '', $check_uri);
  $check_uri = preg_quote($check_uri, '/');
  if (($uri == "")  || (!preg_match("/^" . $check_uri . "/", $uri))){
    // if it didn't match it forces a redirect to the home page
    $uri = '<front>';
  }
  else {
    $uri = 'https://' . $uri;
  }
 _webaccess_do_logon();
  drupal_goto($uri);
}

/**
 * Implements hook_user_logout().
 */
function webaccess_user_logout($account) {
  global $user;
  // allow for webaccess by-pass if we notice a masqurading user
  if (module_exists('masquerade') && (isset($_SESSION['masquerading']) || (isset($user->about_to_masquerade) && $user->about_to_masquerade) ||
      (isset($_GET['webaccess_ignore_logout']) && $_GET['webaccess_ignore_logout']))) {
    unset($user->about_to_masquerade);
    unset($_GET['webaccess_ignore_logout']);
  }
  else {
    // Destroy the current session:
    session_destroy();
    // edge case where this isn't set, avoid notice
    if (isset($_SERVER['COSIGN_SERVICE'])) {
      $service_name = $_SERVER['COSIGN_SERVICE'];
      setcookie( $service_name , "null", time()-1, '/', "", 1 );
    }
    global $base_url;
    $default_path = "https://webaccess.psu.edu/cgi-bin/logout?" . $base_url;
    drupal_goto(variable_get('webaccess_logout_url', $default_path));
  }
}

/**
 * Menu callback; displays the default administration page.
 */
function webaccess_admin() {
  return drupal_get_form('webaccess_admin_settings');
}

/**
 * Implements hook_settings().
 */
function webaccess_admin_settings() {
  global $base_url;
  $form["webaccess_init_enable"] = array(
   '#type' => 'checkbox',
   '#title' => t("Initialize cosign before login."),
   '#default_value' => variable_get("webaccess_init_enable", ""),
   '#description' => t("Not compatible with aggressive mode caching."),
  );
  $form["webaccess_secure_site"] = array(
   '#type' => 'checkbox',
   '#title' => t("Secure Site"),
   '#default_value' => variable_get("webaccess_secure_site", ""),
   '#description' => t("Require login to view any content on this site. Initialize cosign before login must be enabled. Not compatible with aggressive mode caching."),
  );
  $form["webaccess_domain"] = array(
   '#type' => 'textfield',
   '#title' => t("Email Domain"),
   '#default_value' => variable_get("webaccess_domain", "psu.edu"),
   '#size' => 30,
   '#maxlength' => 55,
   '#description' => t("Append this domain name to each new user to generate email address."),
  );
  $default_path = "https://webaccess.psu.edu/cgi-bin/logout?" . $base_url;
  $form["webaccess_logout_url"] = array(
   '#type' => 'textfield',
   '#title' => t("Web Auth logout url"),
   '#default_value' => variable_get("webaccess_logout_url", "$default_path"),
   '#size' => 75,
   '#maxlength' => 255,
   '#description' => t("Enter url to redirect to for logout"),
  );
  $form["webaccess_require_realm"] = array(
   '#type' => 'textfield',
   '#title' => t("Require Realm"),
   '#default_value' => variable_get("webaccess_require_realm", ""),
   '#size' => 30,
   '#maxlength' => 55,
   '#description' => t("Require optional Realm; disabled if left blank. (i.e. - If Guest Accounts should not be allowed require dce.psu.edu as the realm)"),
  );
  $form["webaccess_disallow_username_change"] = array(
    '#type' => 'checkbox',
    '#title' => t('Disable option to change username'),
    '#default_value' => variable_get('webserver_auth_disallow_username', TRUE),
    '#description' => t("Disable the option for users to change their username.  This is most useful when the web server is already authenticating against an external database."),
  );
  return system_settings_form($form);
}

/**
 * Implements hook_menu().
 */
function webaccess_menu() {
  $items = array();
  $items['login'] = array(
    'title' => 'login',
    'page callback' => '_webaccess_call',
    'access callback' => TRUE,
    'weight' => -10,
  );
  $items['user/login'] = array(
    'page callback' => '_webaccess_call',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['login/cosign'] = array(
    'page callback' => '_webaccess_redirect',
    'access callback' => TRUE,
  );
  $items['user/password'] = array(
    'page callback' => '_webaccess_call',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['user/register'] = array(
    'page callback' => '_webaccess_call',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['user/reset'] = array(
    'page callback' => '_webaccess_call',
    'access callback' => TRUE,
    'type' => MENU_CALLBACK,
  );
  $items['admin/config/people/webaccess'] = array(
    'title' => 'WebAccess',
    'description' => ('Authenticates against Cosign'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('webaccess_admin_settings'),
    'access arguments' => array('administer site configuration'),
  );
  return $items;
}

/**
 * Implements hook_form_alter().
 */
function webaccess_form_user_profile_form_alter(&$form, &$form_state, $form_id) {
  // disable option to change username and give reason why
  if (variable_get('webaccess_disallow_username_change', FALSE)) {
    $form['account']['name']['#disabled'] = TRUE;
    $form['account']['name']['#description'] = t('This value has been set by default from the browser login and cannot be changed.');
  }
  // disable password fields and checking on user account edits
  unset($form['account']['pass']);
  unset($form['account']['current_pass']);
  unset($form['account']['current_pass_required_values']);
  $form['#validate'] = array_diff($form['#validate'], array('user_validate_current_pass'));
}

/**
 * Implements hook_form_alter().
 */
function webaccess_form_alter(&$form, &$form_state, $form_id) {
  // add additional submit handler so webaccess can detect the change of user
  if (module_exists('masquerade') && $form_id == 'masquerade_block_1') {
    $form['#submit'] = array_merge(array('_webaccess_masquerade_block_1_submit'), $form['#submit']);
  }
}

/**
 * Submit handler for a masqurade request
 */
function _webaccess_masquerade_block_1_submit($form, &$form_state) {
  global $user;
  $user->about_to_masquerade = TRUE;
}

/**
 * Implements hook_user_view_alter().
 */
function webaccess_user_view_alter(&$build) {
  if (module_exists('masquerade')) {
    // load account from current address (which is a user page)
    $account = menu_get_object('user');
    // taken directly from masquerade handling of hook_user_view().
    // check if user qualifies as admin
    $roles = array_keys(array_filter(variable_get('masquerade_admin_roles', array())));
    $perm = $account->uid == 1 || array_intersect(array_keys((array)$account->roles), $roles) ?
      'masquerade as admin' :
      'masquerade as user';

    global $user;

    if (user_access($perm) && empty($account->masquerading) && $user->uid != $account->uid) {
      $build['masquerade']['#markup'] = l(t('Masquerade as !user', array('!user' => $account->name)),
        'masquerade/switch/' . $account->uid,
        array('query' =>
          array(
            'token' => drupal_get_token('masquerade/switch/' . $account->uid),
            // add webaccess value so we can check it on logout test
            'webaccess_ignore_logout' => TRUE,
          ),
          'destination' => $_GET['q'],
          'attributes' => array('class' => 'masquerade-switch'),
        )
      );
    }
  }
}

/**
 * Implements hook_profiler_builder_ignore_alter().
 */
function webaccess_profiler_builder_ignore_alter(&$ignore_list) {
  $ignore_list[] = 'webaccess_disallow_username_change';
  $ignore_list[] = 'webaccess_domain';
  $ignore_list[] = 'webaccess_logout_url';
  $ignore_list[] = 'webaccess_require_realm';
}

/**
 * Implements hook_profiler_builder_modules_list_alter().
 */
function webaccess_profiler_builder_modules_list_alter(&$list) {
  // specific to webaccess
  unset($list['webaccess']);
  unset($list['webaccess_forms']);
  unset($list['webaccess_authentication_required']);
}

/**
 * Implements hook_page_delivery_callback_alter().
 */
function webaccess_page_delivery_callback_alter(&$callback, $set = FALSE) {
  // switch this page delivery callback so we can better act on it
  // this is an obscure method that helps reduce the chances of
  // incorrectly issuing an access denied message.  This appears
  // to potentially even be browser / server interpretation
  // driven so we need this to help clean up those nagging issues.
  // A common issue this avoids is a logged in user on a webaccess
  // site with public access being given access denied with they
  // have logged into another system with webaccess (so they have the token)
  // but haven't logged into drupal proper.
  if ($callback == 'drupal_deliver_html_page' || $callback == 'boost_deliver_html_page') {
    $callback = 'webaccess_deliver_html_page';
  }
}

/**
 * Callback for webaccess to handle page delivery.
 */
function webaccess_deliver_html_page($page_callback_result) {
  // see if we are getting access denied about to be issued
  if (is_int($page_callback_result) && $page_callback_result == MENU_ACCESS_DENIED) {
    // redirect to home page if it's the login page being requested
    // this isn't a fantastic solution but it's better then issuing
    // a faulty access denied.  There are only certain cases where
    // this is even possible but worth checking for early.
    if (arg(0) == 'login') {
      // see if we have a redirect url, if we do, go to it
      // the code preceeding this will ensure that its not a CSRF
      if (isset($_GET['redirect_url'])) {
        drupal_goto($_GET['redirect_url']);
      }
      // if we have no location, goto the homepage
      drupal_goto('<front>');
    }

    // allow other projects to react to access denied to provide
    // custom methods of attempting to recover from this event
    module_invoke_all('webaccess_about_to_deny_access');
  }
  // allow for boost to take us to the right place
  // boost has methods for helping handle this edge case and
  // is a commonly installed project
  if (module_exists('boost')) {
    boost_deliver_html_page($page_callback_result);
  }
  else {
    // Call original function which drupal will handle by default methods
    drupal_deliver_html_page($page_callback_result);
  }
}

/**
 * Helper function to validate webaccess user is still the user logged in.
 */
function _webaccess_verify_current_user($account) {
  // we need a match of either potential property, remote user more likely
  if (isset($_SERVER['REMOTE_USER']) && $account->name == $_SERVER['REMOTE_USER']) {
    return TRUE;
  }
  if (isset($_SERVER['PHP_AUTH_USER']) && $account->name == $_SERVER['PHP_AUTH_USER']) {
    return TRUE;
  }
  // allow for webaccess by-pass if we notice a masqurading user
  if (module_exists('masquerade') && (isset($_SESSION['masquerading']) || (isset($account->about_to_masquerade) && $account->about_to_masquerade) ||
      (isset($_GET['webaccess_ignore_logout']) && $_GET['webaccess_ignore_logout']))) {
    return TRUE;
  }
  // neither property validates, they aren't the current account
  return FALSE;
}
